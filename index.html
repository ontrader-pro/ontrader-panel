<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>OnTrader Futuros - Score Real</title>
  <style>
    body { background: #101729; color: #fff; font-family: 'Segoe UI',sans-serif; margin: 0; }
    h1 { color: #25f0ff; text-align: center; }
    #panel { max-width: 1100px; margin: 0 auto; padding: 20px; }
    .loading { text-align: center; color: #999; padding: 40px; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #2c344b; padding: 7px 5px; text-align: center; }
    th { background: #1a2233; color: #25f0ff; }
    .bull { color: #36f076; }
    .bear { color: #ff4f60; }
    .alert { background: #232f2f; }
    #error-box { color: #ff6666; text-align: center; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <h1>OnTrader Futuros - Score Real (Binance)</h1>
  <div id="error-box"></div>
  <div id="panel"><div class="loading">Cargando datos...</div></div>
  <script>
  const API_BIN = "https://fapi.binance.com/fapi/v1/ticker/24hr";
  const API_KLINE = (symbol, interval, limit=30) =>
    `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const ALLORIGINS = url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
  const STABLES = /USDT$|USDC$|BUSD$|TUSD$|DAI$|USDP$|GUSD$|USDN$|EUR$|FDUSD$/i;
  const REFRESH_INTERVAL = 180000; // 3 min
  const MAX_SYMBOLS = 20; // <= Para demo, ajustar a tu hosting

  let errorBox = document.getElementById('error-box');
  let panel = document.getElementById('panel');

  // Utilidades EMA/RSI:
  function calcEMA(prices, period) {
    const k = 2 / (period + 1);
    return prices.reduce((acc, val, i) => i === 0 ? val : (val * k + acc * (1 - k)), 0);
  }
  function calcRSI(closes, period=14) {
    let gains = 0, losses = 0;
    for (let i = 1; i < closes.length; i++) {
      let diff = closes[i] - closes[i-1];
      if (diff > 0) gains += diff;
      else losses -= diff;
    }
    let avgGain = gains / period;
    let avgLoss = losses / period || 1e-6;
    let rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }

  async function fetchProxy(url) {
    let resp = await fetch(ALLORIGINS(url));
    let data = await resp.text();
    try { data = JSON.parse(data); } catch {}
    if (Array.isArray(data)) return data;
    if (typeof data === "object" && data.contents) {
      try { return JSON.parse(data.contents); } catch {}
    }
    if (typeof data === "string" && data.startsWith("[")) {
      try { return JSON.parse(data); } catch {}
    }
    throw new Error("API response format not supported");
  }

  // Score real basado en tu lógica de ejemplo:
  function calcScore(params) {
    let score = 1;
    // 1. Precio > mínimo domingo: +3
    if (params.lastPrice > params.minSunday) score += 3;
    // 2. Precio > máximo domingo: +2 extra
    if (params.lastPrice > params.maxSunday) score += 2;
    // 3. 15m: RSI>50 y precio>EMA28: +2 | RSI<50 y precio<EMA28: -2
    if (params.rsi15m > 50 && params.lastPrice > params.ema15m) score += 2;
    if (params.rsi15m < 50 && params.lastPrice < params.ema15m) score -= 2;
    // 4. 5m: RSI>70 y precio>EMA28: +1 | RSI<30 y precio<EMA28: -1
    if (params.rsi5m > 70 && params.lastPrice > params.ema5m) score += 1;
    if (params.rsi5m < 30 && params.lastPrice < params.ema5m) score -= 1;
    // 5. 4m: RSI<15: +0.5 | RSI>85: -0.5
    if (params.rsi4m < 15) score += 0.5;
    if (params.rsi4m > 85) score -= 0.5;
    // Score entre 1 y 10
    if (score > 10) score = 10;
    if (score < 1) score = 1;
    return Math.round(score*100)/100;
  }
  function phase(score) {
    if (score >= 8.1) return '🟢 Overbought';
    if (score >= 6.0) return '🟡 Bullish Incline';
    if (score >= 4.9) return '🟠 Accumulation';
    if (score >= 3.1) return '🔴 Bearish Incline';
    return '🔴 Oversold';
  }

  async function loadAll() {
    panel.innerHTML = '<div class="loading">Cargando top símbolos de futuros...</div>';
    errorBox.textContent = '';
    let tickers = [];
    try {
      tickers = await fetchProxy(API_BIN);
      if (!Array.isArray(tickers)) throw new Error("tickers.filter is not a function");
    } catch (e) {
      panel.innerHTML = '';
      errorBox.textContent = 'Error cargando datos: ' + e.message;
      return;
    }
    // Filtrar
    let onlyFutures = tickers.filter(x=>
      !x.symbol.match(STABLES) &&
      x.symbol.endsWith("USDT") &&
      /^[A-Z0-9]{3,}USDT$/.test(x.symbol)
    );
    onlyFutures = onlyFutures.sort((a,b)=>b.quoteVolume-a.quoteVolume).slice(0,MAX_SYMBOLS);

    // Para cada símbolo, pedir klines en 15m, 5m, 4m, y calcular scores
    let results = [];
    for (let obj of onlyFutures) {
      let params = { lastPrice: Number(obj.lastPrice), symbol: obj.symbol };
      // Pedir máximos y mínimos del domingo (puedes ajustar esto si tienes acceso a velas semanales/días)
      params.minSunday = Number(obj.lowPrice); // simplificado, ideal: buscar vela del domingo
      params.maxSunday = Number(obj.highPrice); // simplificado

      try {
        // 15m
        let klines15 = await fetchProxy(API_KLINE(obj.symbol, '15m', 30));
        let closes15 = klines15.map(x=>Number(x[4]));
        params.ema15m = calcEMA(closes15.slice(-28), 28);
        params.rsi15m = calcRSI(closes15.slice(-15), 14);

        // 5m
        let klines5 = await fetchProxy(API_KLINE(obj.symbol, '5m', 30));
        let closes5 = klines5.map(x=>Number(x[4]));
        params.ema5m = calcEMA(closes5.slice(-28), 28);
        params.rsi5m = calcRSI(closes5.slice(-15), 14);

        // 4m
        let klines4 = await fetchProxy(API_KLINE(obj.symbol, '4m', 30));
        let closes4 = klines4.map(x=>Number(x[4]));
        params.rsi4m = calcRSI(closes4.slice(-15), 14);

      } catch(e) {
        errorBox.textContent = 'Error en símbolo ' + obj.symbol + ': ' + e.message;
        continue; // Saltar símbolo si falla la data
      }
      params.score = calcScore(params);
      params.phase = phase(params.score);
      results.push(params);
    }

    let bull = [...results].sort((a,b)=>b.score-a.score).slice(0,10);
    let bear = [...results].sort((a,b)=>a.score-b.score).slice(0,10);

    let mkTable = arr => `<table><thead>
      <tr><th>Símbolo</th><th>Precio</th><th>Fase</th><th>Score</th></tr>
      </thead><tbody>` +
      arr.map(d=>`<tr>
        <td>${d.symbol}</td>
        <td>${d.lastPrice.toFixed(6)}</td>
        <td>${d.phase}</td>
        <td>${d.score.toFixed(2)}</td>
      </tr>`).join('') + '</tbody></table>';

    panel.innerHTML = `
      <h2>Top 10 Alcista</h2>
      ${mkTable(bull)}
      <h2>Top 10 Bajista</h2>
      ${mkTable(bear)}
      <div style="color:#888;font-size:11px;padding:10px;">Actualizado: ${new Date().toLocaleTimeString()} - Real Data Binance Futuros</div>
    `;
    // Debug log
    console.log('Resultados:', results);
  }

  loadAll();
  setInterval(loadAll, REFRESH_INTERVAL);
  </script>
</body>
</html>
