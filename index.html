<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Panel OnTrader Futuros</title>
  <style>
    body { background: #101729; color: #fff; font-family: 'Segoe UI', Arial, sans-serif; }
    h1 { color: #25f0ff; text-align: center; }
    #panel { max-width: 950px; margin: 20px auto; background: #1a223a; border-radius: 8px; box-shadow: 0 2px 14px #2229  }
    table { width: 100%; border-collapse: collapse; margin-bottom: 15px; }
    th, td { padding: 8px; border-bottom: 1px solid #222; text-align: center; }
    th { background: #181e32; color: #25f0ff; }
    .high { color: #00ff91; }
    .low { color: #ff4562; }
    .mid { color: orange; }
    #error { color: #ff4444; text-align: center; }
  </style>
</head>
<body>
  <h1>Panel OnTrader Futuros (Top 100)</h1>
  <div id="panel">Cargando...</div>
  <div id="error"></div>
  <script>
    // Parámetros principales
    const TOP_LIMIT = 100; // Top 100 por capitalización
    const INTERVAL = "15m";
    const EMA_PERIOD = 28;
    const RSI_PERIOD = 14;
    const STABLES = ['USDT', 'USDC', 'BUSD', 'TUSD', 'DAI', 'USDP', 'GUSD', 'USDN'];

    // Carga previos de localStorage
    let prevScores = JSON.parse(localStorage.getItem('prevScores') || '{}');
    let prevAlerts = JSON.parse(localStorage.getItem('prevAlerts') || '[]');

    // Funciones EMA y RSI
    function ema(arr, period) {
      let k = 2 / (period + 1);
      return arr.reduce((a, v, i) => i ? v * k + a * (1 - k) : v, 0);
    }
    function rsi(arr, period) {
      let gains = 0, losses = 0;
      for (let i = 1; i < arr.length; i++) {
        let diff = arr[i] - arr[i-1];
        if (diff > 0) gains += diff;
        else losses -= diff;
      }
      let avgGain = gains / period, avgLoss = losses / period || 1e-6, rs = avgGain / avgLoss;
      return 100 - 100 / (1 + rs);
    }
    function getPhase(score) {
      if (score <= 3) return '🔴 Oversold';
      if (score < 4.9) return '🔴 Bearish Incline';
      if (score < 6) return '🟠 Accumulation';
      if (score < 8.1) return '🟡 Bullish Incline';
      return '🟢 Overbought';
    }

    function makeTable(data) {
      let head = `<tr>
        <th>Símbolo</th>
        <th>Último Precio</th>
        <th>Score</th>
        <th>Prev Score</th>
        <th>Phase</th>
      </tr>`;
      let rows = data.map(row => {
        let cls = row.score >= 8 ? 'high' : row.score < 4 ? 'low' : 'mid';
        return `<tr>
          <td>${row.symbol}</td>
          <td>${row.lastPrice}</td>
          <td class="${cls}">${row.score}</td>
          <td>${row.prevScore}</td>
          <td>${row.phase}</td>
        </tr>`;
      }).join('');
      return `<table>${head}${rows}</table>`;
    }

    async function main() {
      try {
        document.getElementById('panel').innerHTML = 'Cargando...';
        document.getElementById('error').textContent = '';
        let res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let tickers = await res.json();
        console.log("Tickers recibidos:", tickers.length);

        // Filtrar stablecoins
        tickers = tickers.filter(t =>
          !STABLES.some(stable => t.symbol.endsWith(stable)) &&
          t.symbol.endsWith('USDT')
        );
        tickers = tickers.sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume)).slice(0, TOP_LIMIT);

        let results = [];
        let newPrevScores = {};
        let newAlerts = prevAlerts.slice();

        for (let t of tickers) {
          let symbol = t.symbol;
          try {
            let url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=100`;
            let klineRes = await fetch(url);
            let klines = await klineRes.json();

            if (!Array.isArray(klines) || klines.length < 30) {
              console.warn("No hay suficientes klines para", symbol, klines);
              continue;
            }

            let closes = klines.map(x=>parseFloat(x[4]));
            let ema28 = ema(closes.slice(-EMA_PERIOD-1), EMA_PERIOD);
            let rsi14 = rsi(closes.slice(-RSI_PERIOD-1), RSI_PERIOD);
            let lastPrice = parseFloat(t.lastPrice);

            // Sunday detection (último domingo en los klines)
            let minSunday=Infinity, maxSunday=-Infinity;
            let latestSunday=0;
            klines.forEach(arr=>{
              let ts = arr[0];
              let date = new Date(ts);
              if(date.getUTCDay()===0 && date.getTime()>latestSunday){
                latestSunday = date.setUTCHours(0,0,0,0);
              }
            });
            klines.forEach(arr=>{
              let ts = arr[0];
              let date = new Date(ts);
              if(date.getUTCDay()===0 && date.setUTCHours(0,0,0,0)===latestSunday){
                let low = parseFloat(arr[3]), high = parseFloat(arr[2]);
                if(low < minSunday) minSunday = low;
                if(high > maxSunday) maxSunday = high;
              }
            });
            if(minSunday===Infinity) {
              minSunday = Math.min(...klines.map(a=>parseFloat(a[3])));
              console.warn("No se encontró minSunday para", symbol, "usa:", minSunday);
            }
            if(maxSunday===-Infinity) {
              maxSunday = Math.max(...klines.map(a=>parseFloat(a[2])));
              console.warn("No se encontró maxSunday para", symbol, "usa:", maxSunday);
            }

            // Score principal
            let score = 1;
            if(lastPrice > minSunday) score+=3;
            if(lastPrice > ema28) score+=2;
            if(rsi14 > 55) score+=2;
            if(lastPrice < ema28) score-=2;
            if(rsi14 < 45) score-=2;
            if(lastPrice > maxSunday) score+=2;
            if(lastPrice < minSunday) score-=2;
            score = Math.max(1, Math.min(10, score));
            let phase = getPhase(score);

            // Score previo (de localStorage)
            let prevScore = prevScores[symbol] || score;
            newPrevScores[symbol] = score;

            // Alerta si cambia la fase
            if (prevScore !== score) {
              newAlerts.push({ time: Date.now(), symbol, prevScore, score, phase });
              if (newAlerts.length > 20) newAlerts = newAlerts.slice(-20);
            }

            // Log para depuración
            console.log(`SYM:${symbol} P:${lastPrice} EMA:${ema28.toFixed(4)} RSI:${rsi14.toFixed(2)} MinDom:${minSunday} MaxDom:${maxSunday} SCORE:${score} PHASE:${phase}`);

            // Guardar resultado
            results.push({ symbol, lastPrice, score, prevScore, phase });

          } catch(err) {
            console.error("Error procesando símbolo:", symbol, err);
          }
        }

        // Guardar score previo y alertas en localStorage
        localStorage.setItem('prevScores', JSON.stringify(newPrevScores));
        localStorage.setItem('prevAlerts', JSON.stringify(newAlerts));

        // Renderiza la tabla
        document.getElementById('panel').innerHTML = makeTable(results);

      } catch(e) {
        document.getElementById('panel').innerHTML = '';
        document.getElementById('error').textContent = 'Error cargando datos: '+(e.message||e);
        console.error("ERROR GLOBAL:", e);
      }
    }
    main();
  </script>
</body>
</html>
