<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>√çndice OnTrader</title>
  <style>
    body { background:#101729; color:#fff; font-family:sans-serif; margin:0; padding:20px }
    h1 { text-align:center; color:#25f0ff }
    #panel { overflow-x:auto; margin-top:20px }
    table { width:100%; border-collapse:collapse; margin-bottom:20px }
    th, td { border:1px solid #333; padding:6px; text-align:center; min-width:80px }
    thead { background:#1f2a44; color:#25f0ff }
    .high { color:limegreen; font-weight:bold }
    .mid  { color:orange;    font-weight:bold }
    .low  { color:red;       font-weight:bold }
    #alerta {
      position:fixed; bottom:20px; right:20px;
      background:#ff4444; color:#fff;
      padding:10px 15px; border-radius:5px;
      display:none; box-shadow:0 0 6px rgba(0,0,0,0.5);
      z-index:1000;
    }
  </style>
</head>
<body>
  <h1>√çndice OnTrader</h1>
  <div id="panel">Inicializando‚Ä¶</div>
  <div id="alerta"></div>

  <script>
  // CONFIG: top 200 CoinGecko (sin stablecoins)
  const STABLES = ['usdt','usdc','busd','dai','tusd','usdp','gusd','usdn'];
  const CG_URL = 'https://api.coingecko.com/api/v3/coins/markets'
               + '?vs_currency=usd&order=market_cap_desc&per_page=200&page=1&sparkline=true';
  // proxy CORS para Binance
  const proxy = url => 'https://thingproxy.freeboard.io/fetch/' + url;

  // Helpers EMA-28 y RSI-14
  function calcEMA(vals, p) {
    const k = 2/(p + 1);
    return vals.reduce((a, v, i) => i ? v*k + a*(1-k) : v, 0);
  }
  function calcRSI(arr) {
    let gains=0, losses=0;
    for (let i=1; i<arr.length; i++){
      const d = arr[i] - arr[i-1];
      if (d>0) gains += d;
      else losses -= d;
    }
    const avgG = gains/(arr.length-1),
          avgL = losses/(arr.length-1) || 1e-6,
          rs   = avgG/avgL;
    return 100 - (100/(1+rs));
  }

  let heavyCache = null, heavyTS = 0;
  let dataGlobal = [], alerted = new Set();

  // HEAVY LOAD: EMA+RSI (28h), Domingo (1d) ‚Äî cache TTL 1h
  async function heavyLoad(){
    const now = Date.now();
    if (heavyCache && (now - heavyTS) < 60*60*1000) return heavyCache;
    // fetch top200
    const cg = await fetch(CG_URL).then(r=>r.json());
    const arr = cg.filter(c => !STABLES.includes(c.symbol.toLowerCase()));
    const data = await Promise.all(arr.map(async c => {
      const sym = c.symbol.toUpperCase();
      // 1) cierres horarios
      let closes1h = [];
      try {
        const kl1h = await fetch(
          proxy(`https://api.binance.com/api/v3/klines?symbol=${sym}USDT&interval=1h&limit=28`)
        ).then(r=>r.json());
        closes1h = kl1h.map(k=>parseFloat(k[4]));
      } catch(e) {
        console.warn('KL1H err', sym, e);
      }
      const ema28 = closes1h.length ? calcEMA(closes1h,28) : c.current_price;
      const rsi14 = closes1h.length >= 15 ? calcRSI(closes1h.slice(-15)) : 50;
      // 2) vela diaria domingo
      let maxD=NaN, minD=NaN;
      try {
        const kl1d = await fetch(
          proxy(`https://api.binance.com/api/v3/klines?symbol=${sym}USDT&interval=1d&limit=8`)
        ).then(r=>r.json());
        const found = kl1d.reverse().find(k=>new Date(k[0]).getUTCDay()===0) || [];
        maxD = parseFloat(found[2])||NaN;
        minD = parseFloat(found[3])||NaN;
      } catch(e) {
        console.warn('KL1D err', sym, e);
      }
      return { id: c.id, symbol: sym, ema28, rsi14, maxD, minD };
    }));
    heavyCache = data;
    heavyTS = now;
    return data;
  }

  // LIGHT LOAD: precios y score ‚Äî cada 60s
  async function lightLoad(heavy){
    // fetch precios
    const ids = heavy.map(h=>h.id).join(',');
    let prices = {};
    try {
      prices = await fetch(
        `https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`
      ).then(r=>r.json());
    } catch(e){
      console.error('Price fetch err', e);
    }
    // calcular score
    dataGlobal = heavy.map(h => {
      const precio = prices[h.id]?.usd || 0;
      let score = 0;
      if (!isNaN(h.minD) && precio > h.minD)                 score += 1;
      if (!isNaN(h.minD) && !isNaN(h.maxD) && precio > (h.minD+h.maxD)/2) score += 2;
      if (!isNaN(h.maxD) && precio > h.maxD)                 score += 2;
      if (!isNaN(h.minD) && precio < h.minD)                 score += 2;
      if ((precio % 1) < 0.2)                                score += 1; // cierre redondo
      // EMA-28: +2 / -2
      if (precio > h.ema28)          score += 2;
      else                            score -= 2;
      // RSI-14: +1 / -1
      if (h.rsi14 > 50)              score += 1;
      else if (h.rsi14 < 50)         score -= 1;
      // clamp 1‚Äì10
      score = Math.min(10, Math.max(1, score));
      // fase
      let fase = 'üî¥ Debilidad excesiva';
      if      (score >= 8.1) fase = 'üü¢ Fuerza excesiva';
      else if (score >= 6.0) fase = 'üü° Fase de inclinaci√≥n alcista';
      else if (score >= 4.9) fase = 'üü† Fase de acumulaci√≥n';
      else if (score >= 3.1) fase = 'üî¥ Fase de inclinaci√≥n bajista';
      return {
        cripto: h.symbol,
        precio,
        indice: score.toFixed(1),
        fase
      };
    });
    renderTables();
    mostrarAlertas();
  }

  // Render Top10 y Bottom10
  function renderTables(){
    const top = [...dataGlobal].sort((a,b)=>b.indice-a.indice).slice(0,10);
    const bot = [...dataGlobal].sort((a,b)=>a.indice-b.indice).slice(0,10);
    const mk = arr => `
      <table><thead>
        <tr><th>Cripto</th><th>Precio</th><th>√çndice</th><th>Fase</th></tr>
      </thead><tbody>
        ${arr.map(d=>`
          <tr>
            <td>${d.cripto}</td>
            <td>${d.precio.toLocaleString()}</td>
            <td class="${d.indice>=8?'high':d.indice>=5?'mid':'low'}">${d.indice}</td>
            <td>${d.fase}</td>
          </tr>`).join('')}
      </tbody></table>`;
    document.getElementById('panel').innerHTML =
      `<h2>Top 10 Alcistas</h2>${mk(top)}<h2>Top 10 Bajistas</h2>${mk(bot)}`;
  }

  // Alertas si √≠ndice ‚â•6 o ‚â§3
  function mostrarAlertas(){
    const el = document.getElementById('alerta');
    const n  = dataGlobal.find(d=>
      !alerted.has(d.cripto) && (d.indice >= 6 || d.indice <= 3)
    );
    if (n) {
      alerted.add(n.cripto);
      el.innerText = `üö® ${n.cripto}: ${n.fase}`;
      el.style.display = 'block';
      new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg').play();
      setTimeout(()=>el.style.display='none', 10000);
    }
  }

  // Orquestaci√≥n: heavyLoad cada hora, lightLoad cada 60s
  (async ()=>{
    const heavy = await heavyLoad();     // inicial
    await lightLoad(heavy);              // inicial
    setInterval(()=>lightLoad(heavy), 60*1000);
    setInterval(()=>heavyLoad(), 60*60*1000);
  })();
  </script>
</body>
</html>
