<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>OnTrader Index Panel</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #101729; color: #fff; font-family: 'Segoe UI', 'Arial', sans-serif; }
    h1 { margin: 0; padding: 10px; text-align: center; color: #25f0ff; font-size: 1.5rem; }
    #progress { text-align: center; font-size: 1rem; color: #0ff; margin: 8px 0;}
    #panel { padding: 0 10px; }
    #error-box { text-align: center; color: #f55; padding: 8px; }
    table { width: 100%; border-collapse: collapse; margin: 18px 0; }
    th, td { border: 1px solid #222c44; padding: 6px; text-align: center; font-size: 0.96em;}
    thead { background: #1f2a44; color: #25f0ff; }
    .high { color: #27ff57; font-weight: bold; }
    .mid { color: orange; }
    .low { color: #ff5757; }
    .bullish { background: rgba(0,255,0,0.07);}
    .bearish { background: rgba(255,0,0,0.07);}
    .change-up { background: rgba(0,255,0,0.15);}
    .change-down { background: rgba(255,0,0,0.13);}
    #alert-box { position: fixed; bottom: 10px; right: 10px; background: #ff4444; color: #fff; padding: 8px 12px; border-radius: 4px; display: none; z-index: 1000; }
    @media (max-width: 800px) {
      th, td { font-size: 0.87em; }
    }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel</h1>
  <div id="progress"></div>
  <div id="panel"><div style="text-align:center; padding:50px;">Cargando datos‚Ä¶</div></div>
  <div id="error-box"></div>
  <div id="alert-box"></div>
  <script>
const API_BASE = "https://fapi.binance.com";
const CONFIG = {
  refreshInterval: 120000, // 2 min
  top: 100,
  stableSuffixes: ['USDT','BUSD','TUSD','USDC','USDP','DAI','GUSD','USDN'],
  minSundayLookback: 14, // en d√≠as (para daily candle)
};

const panel = document.getElementById('panel');
const progress = document.getElementById('progress');
const errorBox = document.getElementById('error-box');
const alertBox = document.getElementById('alert-box');
const sound = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
let cache = [], prevScores = {}, alerts = [], prevData = {};
let loadingStep = 0, loadingMax = 1;

function showProgress(text) { progress.innerText = text; }
function hideProgress() { progress.innerText = ""; }
function showError(msg) { errorBox.innerText = msg; }
function clearError() { errorBox.innerText = ""; }
function showAlert(sym, ph, score, prev) {
  alertBox.innerText = `üö® ${sym}: ${ph} (Score: ${score.toFixed(2)}, Prev: ${prev ? prev.toFixed(2) : "‚Äî"})`;
  alertBox.style.display = "block";
  try { sound.currentTime = 0; sound.play(); } catch {}
  setTimeout(()=>{ alertBox.style.display = "none"; }, 8000);
}
function log(...args) { console.log(...args); }

// Helpers
function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
function nowStr() { return new Date().toLocaleTimeString(); }

// Utilidad para ver si es stable
function isStable(symbol) {
  return CONFIG.stableSuffixes.some(sfx => symbol.endsWith(sfx));
}

// Fetch lista de s√≠mbolos perpetuos top 100 (excluyendo stablecoins)
async function getTop100Perpetuals() {
  showProgress("Obteniendo top 100 futuros perpetuos...");
  const info = await fetch(API_BASE + "/fapi/v1/exchangeInfo").then(r=>r.json());
  let allPerp = info.symbols.filter(s => 
    s.contractType === "PERPETUAL" && 
    !isStable(s.symbol) && 
    s.status === "TRADING"
  );
  // Ordenar por volumen en 24h (hay que consultar tickers)
  let tickers = await fetch(API_BASE + "/fapi/v1/ticker/24hr").then(r=>r.json());
  let volMap = {};
  tickers.forEach(tk => { volMap[tk.symbol] = +tk.quoteVolume; });
  allPerp.forEach(s => { s.vol = volMap[s.symbol] || 0; });
  allPerp = allPerp.sort((a,b)=>b.vol-a.vol).slice(0, CONFIG.top);
  log("Seleccionados:", allPerp.map(x=>x.symbol));
  return allPerp;
}

// Fetch OHLCV data, devuelve array de closes
async function getOHLCV(symbol, interval, limit) {
  let url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`No data for ${symbol} @ ${interval}`);
  const arr = await resp.json();
  return arr.map(x => +x[4]);
}

// RSI est√°ndar (CLOSE array)
function calcRSI(closes, period=14) {
  let gains = 0, losses = 0;
  for(let i=1; i<period+1; i++) {
    const diff = closes[i] - closes[i-1];
    if(diff > 0) gains += diff; else losses -= diff;
  }
  const avgGain = gains/period, avgLoss = (losses||1e-7)/period;
  const rs = avgGain/avgLoss;
  return 100-(100/(1+rs));
}
// EMA est√°ndar (CLOSE array)
function calcEMA(closes, period=28) {
  let k = 2/(period+1), ema = closes[0];
  for(let i=1; i<closes.length; i++) {
    ema = closes[i]*k + ema*(1-k);
  }
  return ema;
}

// Buscar el min/max del domingo en las √∫ltimas 14 velas daily
function getSundayMinMax(closesArr, openTimeArr) {
  let min = +Infinity, max = -Infinity;
  let sundayIdx = null;
  for(let i=0;i<closesArr.length;i++) {
    let dt = new Date(openTimeArr[i]);
    if (dt.getUTCDay() === 0) { // Domingo
      if (closesArr[i]<min) min=closesArr[i];
      if (closesArr[i]>max) max=closesArr[i];
      sundayIdx = i;
    }
  }
  return sundayIdx!==null ? { min, max } : { min: closesArr[0], max: closesArr[0] };
}

// NUEVA F√ìRMULA DE SCORE
function computeScoreV2(d) {
  let score = 1;
  // 1) Precio > min Sunday: +3
  if (d.lastPrice > d.sundayMin) score += 3;
  // 1b) Precio > max Sunday: +2 extra
  if (d.lastPrice > d.sundayMax) score += 2;
  // 2) 15m: RSI>50 y Price>EMA28: +2 | RSI<50 y Price<EMA28: -2
  if (d.rsi15m > 50 && d.lastPrice > d.ema15m) score += 2;
  else if (d.rsi15m < 50 && d.lastPrice < d.ema15m) score -= 2;
  // 3) 5m: RSI>70 y Price>EMA28: +1 | RSI<30 y Price<EMA28: -1
  if (d.rsi5m > 70 && d.lastPrice > d.ema5m) score += 1;
  else if (d.rsi5m < 30 && d.lastPrice < d.ema5m) score -= 1;
  // 4) 4m: RSI<15: +0.5 | RSI>85: -0.5
  if (d.rsi4m < 15) score += 0.5;
  else if (d.rsi4m > 85) score -= 0.5;
  // Clamp
  return Math.max(1, Math.min(10, score));
}
function phaseText(score) {
  if (score <= 3.0) return 'üî¥ Oversold';
  else if (score < 4.9) return 'üî¥ Bearish Incline';
  else if (score < 6.0) return 'üü† Accumulation';
  else if (score < 8.1) return 'üü° Bullish Incline';
  else return 'üü¢ Overbought';
}

// MAIN: cargar datos y renderizar
async function loadAndRender() {
  try {
    showProgress("Iniciando‚Ä¶");
    clearError();
    alerts = [];
    let symbols = await getTop100Perpetuals();
    loadingStep = 0; loadingMax = symbols.length;
    let dataArr = [];
    // Para score prev
    let scoreMapPrev = JSON.parse(localStorage.getItem('ontrader-score-prev')||"{}");
    for (let symObj of symbols) {
      loadingStep++;
      showProgress(`Procesando ${symObj.symbol} (${loadingStep}/${loadingMax})`);
      try {
        // OHLCV para daily, 15m, 5m, 4m
        let [ohlcvD, ohlcv15, ohlcv5, ohlcv4] = await Promise.all([
          fetch(`${API_BASE}/fapi/v1/klines?symbol=${symObj.symbol}&interval=1d&limit=${CONFIG.minSundayLookback}`)
            .then(r=>r.json()),
          getOHLCV(symObj.symbol, '15m', 40),
          getOHLCV(symObj.symbol, '5m', 40),
          getOHLCV(symObj.symbol, '4m', 40)
        ]);
        let closesD = ohlcvD.map(x=>+x[4]);
        let openTimesD = ohlcvD.map(x=>+x[0]);
        let {min:sundayMin, max:sundayMax} = getSundayMinMax(closesD, openTimesD);

        let lastPrice = +ohlcv15[ohlcv15.length-1];
        let ema15m = calcEMA(ohlcv15, 28);
        let rsi15m = calcRSI(ohlcv15, 14);
        let ema5m = calcEMA(ohlcv5, 28);
        let rsi5m = calcRSI(ohlcv5, 14);
        let rsi4m = calcRSI(ohlcv4, 14);

        let d = {
          symbol: symObj.symbol,
          lastPrice, sundayMin, sundayMax,
          ema15m, rsi15m,
          ema5m, rsi5m,
          rsi4m
        };
        d.score = computeScoreV2(d);
        d.phase = phaseText(d.score);
        d.scorePrev = scoreMapPrev[d.symbol] || null;

        // Registrar alerta si hay cambio de fase/score
        if (d.scorePrev !== null && d.score !== d.scorePrev) {
          alerts.push({
            time: Date.now(),
            symbol: d.symbol,
            phase: d.phase,
            score: d.score,
            scorePrev: d.scorePrev
          });
          showAlert(d.symbol, d.phase, d.score, d.scorePrev);
        }
        dataArr.push(d);
        scoreMapPrev[d.symbol] = d.score;
      } catch(e) {
        log(`Error procesando ${symObj.symbol}:`, e);
      }
      // Evitar bloqueo por rate limit (pausa ligera cada 5)
      if (loadingStep%5===0) await sleep(300);
    }
    // Guardar en localStorage para scorePrev y dataArr
    localStorage.setItem('ontrader-score-prev', JSON.stringify(scoreMapPrev));
    localStorage.setItem('ontrader-latest', JSON.stringify(dataArr));
    cache = dataArr;
    renderTables();
    hideProgress();
  } catch(e) {
    showError("Error cargando datos: " + e.message);
    log(e);
    // Intentar mostrar desde cach√©
    let backup = localStorage.getItem('ontrader-latest');
    if (backup) {
      cache = JSON.parse(backup);
      renderTables();
      hideProgress();
    }
  }
}

function renderTables() {
  // Top 10 bullish, bearish
  let sorted = cache.slice().sort((a,b)=>b.score-a.score);
  let top10Bull = sorted.slice(0,10);
  let top10Bear = sorted.slice(-10).reverse();

  // Top 10 subidas de score (actual - prev)
  let ups = cache
    .filter(x=>x.scorePrev!==null)
    .map(x=>({ ...x, diff: x.score-x.scorePrev }))
    .filter(x=>x.diff>0)
    .sort((a,b)=>b.diff-a.diff)
    .slice(0,10);

  let downs = cache
    .filter(x=>x.scorePrev!==null)
    .map(x=>({ ...x, diff: x.score-x.scorePrev }))
    .filter(x=>x.diff<0)
    .sort((a,b)=>a.diff-b.diff)
    .slice(0,10);

  // Tabla de alertas (m√°x 20)
  let last20alerts = alerts.slice(-20);

  panel.innerHTML = `
  <h2>Top 10 Bullish</h2>
  ${makeTable(top10Bull)}
  <h2>Top 10 Bearish</h2>
  ${makeTable(top10Bear)}
  <h2>Top 10 Cambios Score Al Alza</h2>
  ${makeTable(ups,true)}
  <h2>Top 10 Cambios Score A la Baja</h2>
  ${makeTable(downs,true)}
  <h2>√öltimas 20 Alertas</h2>
  ${alertsTable(last20alerts)}
  `;
}

function makeTable(arr, showDiff=false) {
  let html = `<table><thead><tr>
    <th>S√≠mbolo</th><th>Precio</th><th>Score</th><th>Score Prev</th>${showDiff?'<th>Cambio</th>':''}<th>Phase</th>
    </tr></thead><tbody>`;
  for(let d of arr) {
    let cls = d.score>=8?'high':d.score>=5?'mid':'low';
    let rowCls = '';
    if (d.phase.includes('Bullish')) rowCls = 'bullish';
    if (d.phase.includes('Bearish')) rowCls = 'bearish';
    if (showDiff && d.diff>0) rowCls += ' change-up';
    if (showDiff && d.diff<0) rowCls += ' change-down';
    html += `<tr class="${rowCls}"><td>${d.symbol}</td>
    <td>${d.lastPrice.toFixed(6)}</td>
    <td class="${cls}">${d.score.toFixed(2)}</td>
    <td>${d.scorePrev!==null?d.scorePrev.toFixed(2):'‚Äî'}</td>
    ${showDiff?`<td>${d.diff>0?'+':''}${d.diff.toFixed(2)}</td>`:''}
    <td>${d.phase}</td>
    </tr>`;
  }
  html += "</tbody></table>";
  return html;
}
function alertsTable(arr) {
  let html = `<table><thead><tr><th>Hora</th><th>S√≠mbolo</th><th>Score</th><th>Score Prev</th><th>Phase</th></tr></thead><tbody>`;
