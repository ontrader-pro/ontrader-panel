<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>OnTrader Index Panel</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #101729; color: #fff; font-family: 'Segoe UI', 'Arial', sans-serif; }
    h1 { margin: 0; padding: 10px; text-align: center; color: #25f0ff; font-size: 1.5rem; }
    #progress { text-align: center; font-size: 1rem; color: #0ff; margin: 8px 0;}
    #panel { padding: 0 10px; }
    #error-box { text-align: center; color: #f55; padding: 8px; }
    table { width: 100%; border-collapse: collapse; margin: 18px 0; }
    th, td { border: 1px solid #222c44; padding: 6px; text-align: center; font-size: 0.96em;}
    thead { background: #1f2a44; color: #25f0ff; }
    .high { color: #27ff57; font-weight: bold; }
    .mid { color: orange; }
    .low { color: #ff5757; }
    .bullish { background: rgba(0,255,0,0.07);}
    .bearish { background: rgba(255,0,0,0.07);}
    .change-up { background: rgba(0,255,0,0.15);}
    .change-down { background: rgba(255,0,0,0.13);}
    #alert-box { position: fixed; bottom: 10px; right: 10px; background: #ff4444; color: #fff; padding: 8px 12px; border-radius: 4px; display: none; z-index: 1000; }
    @media (max-width: 800px) {
      th, td { font-size: 0.87em; }
    }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel</h1>
  <div id="progress"></div>
  <div id="panel"><div style="text-align:center; padding:50px;">Loading...</div></div>
  <div id="error-box"></div>
  <div id="alert-box"></div>
  <script>
const API_BASE = "https://fapi.binance.com";
const CONFIG = {
  refreshInterval: 120000, // 2 min
  top: 100,
  stableSuffixes: ['USDT','BUSD','TUSD','USDC','USDP','DAI','GUSD','USDN'],
  minSundayLookback: 14, // days (for daily candle)
};

const panel = document.getElementById('panel');
const progress = document.getElementById('progress');
const errorBox = document.getElementById('error-box');
const alertBox = document.getElementById('alert-box');
const sound = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
let cache = [], alerts = [];

// Helpers
function showProgress(text) { progress.innerText = text; }
function hideProgress() { progress.innerText = ""; }
function showError(msg) { errorBox.innerText = msg; }
function clearError() { errorBox.innerText = ""; }
function showAlert(sym, ph, score, prev) {
  alertBox.innerText = `ðŸš¨ ${sym}: ${ph} (Score: ${score.toFixed(2)}, Prev: ${prev ? prev.toFixed(2) : "â€”"})`;
  alertBox.style.display = "block";
  try { sound.currentTime = 0; sound.play(); } catch {}
  setTimeout(()=>{ alertBox.style.display = "none"; }, 8000);
}
function log(...args) { console.log(...args); }
function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

function isStable(symbol) {
  return CONFIG.stableSuffixes.some(sfx => symbol.endsWith(sfx));
}

async function getTop100Perpetuals() {
  showProgress("Getting top 100 perpetual futures...");
  const info = await fetch(API_BASE + "/fapi/v1/exchangeInfo").then(r=>r.json());
  let allPerp = info.symbols.filter(s => 
    s.contractType === "PERPETUAL" && 
    !isStable(s.symbol) && 
    s.status === "TRADING"
  );
  let tickers = await fetch(API_BASE + "/fapi/v1/ticker/24hr").then(r=>r.json());
  let volMap = {};
  tickers.forEach(tk => { volMap[tk.symbol] = +tk.quoteVolume; });
  allPerp.forEach(s => { s.vol = volMap[s.symbol] || 0; });
  allPerp = allPerp.sort((a,b)=>b.vol-a.vol).slice(0, CONFIG.top);
  log("Selected:", allPerp.map(x=>x.symbol));
  return allPerp;
}

async function getOHLCV(symbol, interval, limit) {
  let url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`No data for ${symbol} @ ${interval}`);
  const arr = await resp.json();
  return arr.map(x => +x[4]);
}

function calcRSI(closes, period=14) {
  let gains = 0, losses = 0;
  for(let i=1; i<period+1; i++) {
    const diff = closes[i] - closes[i-1];
    if(diff > 0) gains += diff; else losses -= diff;
  }
  const avgGain = gains/period, avgLoss = (losses||1e-7)/period;
  const rs = avgGain/avgLoss;
  return 100-(100/(1+rs));
}
function calcEMA(closes, period=28) {
  let k = 2/(period+1), ema = closes[0];
  for(let i=1; i<closes.length; i++) {
    ema = closes[i]*k + ema*(1-k);
  }
  return ema;
}

function getSundayMinMax(closesArr, openTimeArr) {
  let min = +Infinity, max = -Infinity;
  let sundayIdx = null;
  for(let i=0;i<closesArr.length;i++) {
    let dt = new Date(openTimeArr[i]);
    if (dt.getUTCDay() === 0) {
      if (closesArr[i]<min) min=closesArr[i];
      if (closesArr[i]>max) max=closesArr[i];
      sundayIdx = i;
    }
  }
  return sundayIdx!==null ? { min, max } : { min: closesArr[0], max: closesArr[0] };
}

function computeScoreV2(d) {
  let score = 1;
  if (d.lastPrice > d.sundayMin) score += 3;
  if (d.lastPrice > d.sundayMax) score += 2;
  if (d.rsi15m > 50 && d.lastPrice > d.ema15m) score += 2;
  else if (d.rsi15m < 50 && d.lastPrice < d.ema15m) score -= 2;
  if (d.rsi5m > 70 && d.lastPrice > d.ema5m) score += 1;
  else if (d.rsi5m < 30 && d.lastPrice < d.ema5m) score -= 1;
  if (d.rsi4m < 15) score += 0.5;
  else if (d.rsi4m > 85) score -= 0.5;
  return Math.max(1, Math.min(10, score));
}
function phaseText(score) {
  if (score <= 3.0) return 'ðŸ”´ Oversold';
  else if (score < 4.9) return 'ðŸ”´ Bearish Incline';
  else if (score < 6.0) return 'ðŸŸ  Accumulation';
  else if (score < 8.1) return 'ðŸŸ¡ Bullish Incline';
  else return 'ðŸŸ¢ Overbought';
}

// MAIN: Batched, fast first 20
async function loadAndRenderBatchedFast() {
  try {
    showProgress("Starting...");
    clearError();
    alerts = [];
    let symbols = await getTop100Perpetuals();
    let loadingStep = 0, loadingMax = symbols.length;
    let dataArr = [];
    let scoreMapPrev = JSON.parse(localStorage.getItem('ontrader-score-prev')||"{}");
    let BATCH_SIZE = 20;

    async function processSymbol(idx) {
      let sym = symbols[idx].symbol;
      let [ohlcvD, ohlcv15, ohlcv5, ohlcv4] = await Promise.all([
        fetch(`${API_BASE}/fapi/v1/klines?symbol=${sym}&interval=1d&limit=${CONFIG.minSundayLookback}`).then(r=>r.json()),
        getOHLCV(sym, '15m', 40),
        getOHLCV(sym, '5m', 40),
        getOHLCV(sym, '4m', 40)
      ]);
      let closesD = ohlcvD.map(x=>+x[4]);
      let openTimesD = ohlcvD.map(x=>+x[0]);
      let {min:sundayMin, max:sundayMax} = getSundayMinMax(closesD, openTimesD);

      let lastPrice = +ohlcv15[ohlcv15.length-1];
      let ema15m = calcEMA(ohlcv15, 28);
      let rsi15m = calcRSI(ohlcv15, 14);
      let ema5m = calcEMA(ohlcv5, 28);
      let rsi5m = calcRSI(ohlcv5, 14);
      let rsi4m = calcRSI(ohlcv4, 14);

      let d = {
        symbol: sym,
        lastPrice, sundayMin, sundayMax,
        ema15m, rsi15m,
        ema5m, rsi5m,
        rsi4m
      };
      d.score = computeScoreV2(d);
      d.phase = phaseText(d.score);
      d.scorePrev = scoreMapPrev[d.symbol] || null;

      if (d.scorePrev !== null && d.score !== d.scorePrev) {
        alerts.push({
          time: Date.now(),
          symbol: d.symbol,
          phase: d.phase,
          score: d.score,
          scorePrev: d.scorePrev
        });
        showAlert(d.symbol, d.phase, d.score, d.scorePrev);
      }
      scoreMapPrev[d.symbol] = d.score;
      return d;
    }

    // --- First batch (FAST LOAD) ---
    showProgress("Loading first 20 coins...");
    let batch0 = [];
    for (let i=0; i<BATCH_SIZE && i<symbols.length; ++i) {
      loadingStep++;
      batch0.push(processSymbol(i));
    }
    dataArr = await Promise.all(batch0);
    cache = dataArr.slice();
    renderTables();
    showProgress(`Loaded 20/${symbols.length}...`);

    // --- Rest of batches (in the background, less aggressive) ---
    for (let start=BATCH_SIZE; start<symbols.length; start+=BATCH_SIZE) {
      let tasks = [];
      for (let i=start; i<start+BATCH_SIZE && i<symbols.length; ++i) {
        loadingStep++;
        tasks.push(processSymbol(i));
      }
      let partial = await Promise.all(tasks);
      dataArr = dataArr.concat(partial);
      cache = dataArr.slice();
      renderTables();
      showProgress(`Loaded ${Math.min(loadingStep,symbols.length)}/${symbols.length}...`);
      await sleep(600); // Prevent API throttling, tweak if needed
    }

    // --- Save cache ---
    localStorage.setItem('ontrader-score-prev', JSON.stringify(scoreMapPrev));
    localStorage.setItem('ontrader-latest', JSON.stringify(dataArr));
    hideProgress();

  } catch(e) {
    showError("Error loading data: " + e.message);
    log(e);
    let backup = localStorage.getItem('ontrader-latest');
    if (backup) {
      cache = JSON.parse(backup);
      renderTables();
      hideProgress();
    }
  }
}

function renderTables() {
  let sorted = cache.slice().sort((a,b)=>b.score-a.score);
  let top10Bull = sorted.slice(0,10);
  let top10Bear = sorted.slice(-10).reverse();

  let ups = cache
    .filter(x=>x.scorePrev!==null)
    .map(x=>({ ...x, diff: x.score-x.scorePrev }))
    .filter(x=>x.diff>0)
    .sort((a,b)=>b.diff-a.diff)
    .slice(0,10);

  let downs = cache
    .filter(x=>x.scorePrev!==null)
    .map(x=>({ ...x, diff: x.score-x.scorePrev }))
    .filter(x=>x.diff<0)
    .sort((a,b)=>a.diff-b.diff)
    .slice(0,10);

  let last20alerts = alerts.slice(-20);

  panel.innerHTML = `
  <h2>Top 10 Bullish</h2>
  ${makeTable(top10Bull)}
  <h2>Top 10 Bearish</h2>
  ${makeTable(top10Bear)}
  <h2>Top 10 Score Up Changes</h2>
  ${makeTable(ups,true)}
  <h2>Top 10 Score Down Changes</h2>
  ${makeTable(downs,true)}
  <h2>Last 20 Alerts</h2>
  ${alertsTable(last20alerts)}
  `;
}

function makeTable(arr, showDiff=false) {
  let html = `<table><thead><tr>
    <th>Symbol</th><th>Price</th><th>Score</th><th>Prev. Score</th>${showDiff?'<th>Change</th>':''}<th>Phase</th>
    </tr></thead><tbody>`;
  for(let d of arr) {
    let cls = d.score>=8?'high':d.score>=5?'mid':'low';
    let rowCls = '';
    if (d.phase.includes('Bullish')) rowCls = 'bullish';
    if (d.phase.includes('Bearish')) rowCls = 'bearish';
    if (showDiff && d.diff>0) rowCls += ' change-up';
    if (showDiff && d.diff<0) rowCls += ' change-down';
    html += `<tr class="${rowCls}"><td>${d.symbol}</td>
    <td>${d.lastPrice.toFixed(6)}</td>
    <td class="${cls}">${d.score.toFixed(2)}</td>
    <td>${d.scorePrev!==null?d.scorePrev.toFixed(2):'â€”'}</td>
    ${showDiff?`<td>${d.diff>0?'+':''}${d.diff.toFixed(2)}</td>`:''}
    <td>${d.phase}</td>
    </tr>`;
  }
  html += "</tbody></table>";
  return html;
}
function alertsTable(arr) {
  let html = `<table><thead><tr><th>Time</th><th>Symbol</th><th>Score</th><th>Prev. Score</th><th>Phase</th></tr></thead><tbody>`;
  for(let a of arr) {
    html += `<tr><td>${new Date(a.time).toLocaleTimeString()}</td>
    <td>${a.symbol}</td>
    <td>${a.score.toFixed(2)}</td>
    <td>${a.scorePrev!==null?a.scorePrev.toFixed(2):'â€”'}</td>
    <td>${a.phase}</td>
    </tr>`;
  }
  html += "</tbody></table>";
  return html;
}

// Start!
loadAndRenderBatchedFast();
  </script>
</body>
</html>
