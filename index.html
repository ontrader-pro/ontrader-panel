// Parámetros principales
const TOP_LIMIT = 100; // Top 100 por capitalización
const INTERVAL = "15m";
const EMA_PERIOD = 28;
const RSI_PERIOD = 14;
const STABLES = ['USDT', 'USDC', 'BUSD', 'TUSD', 'DAI', 'USDP', 'GUSD', 'USDN'];

// Carga previos de localStorage
let prevScores = JSON.parse(localStorage.getItem('prevScores') || '{}');
let prevAlerts = JSON.parse(localStorage.getItem('prevAlerts') || '[]');

// Funciones EMA y RSI (asegúrate de tenerlas bien definidas)
function ema(arr, period) {
  let k = 2 / (period + 1);
  return arr.reduce((a, v, i) => i ? v * k + a * (1 - k) : v, 0);
}
function rsi(arr, period) {
  let gains = 0, losses = 0;
  for (let i = 1; i < arr.length; i++) {
    let diff = arr[i] - arr[i-1];
    if (diff > 0) gains += diff;
    else losses -= diff;
  }
  let avgGain = gains / period, avgLoss = losses / period || 1e-6, rs = avgGain / avgLoss;
  return 100 - 100 / (1 + rs);
}
function getPhase(score) {
  if (score <= 3) return '🔴 Oversold';
  if (score < 4.9) return '🔴 Bearish Incline';
  if (score < 6) return '🟠 Accumulation';
  if (score < 8.1) return '🟡 Bullish Incline';
  return '🟢 Overbought';
}

async function main() {
  try {
    document.getElementById('panel').innerHTML = 'Cargando...';
    document.getElementById('error').textContent = '';
    let res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
    let tickers = await res.json();
    console.log("Tickers recibidos:", tickers.length);

    // Filtrar stablecoins
    tickers = tickers.filter(t =>
      !STABLES.some(stable => t.symbol.endsWith(stable)) &&
      t.symbol.endsWith('USDT')
    );
    tickers = tickers.sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume)).slice(0, TOP_LIMIT);

    let results = [];
    let newPrevScores = {};
    let newAlerts = prevAlerts.slice();

    for (let t of tickers) {
      let symbol = t.symbol;
      try {
        let url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=100`;
        let klineRes = await fetch(url);
        let klines = await klineRes.json();

        if (!Array.isArray(klines) || klines.length < 30) {
          console.warn("No hay suficientes klines para", symbol, klines);
          continue;
        }

        let closes = klines.map(x=>parseFloat(x[4]));
        let ema28 = ema(closes.slice(-EMA_PERIOD-1), EMA_PERIOD);
        let rsi14 = rsi(closes.slice(-RSI_PERIOD-1), RSI_PERIOD);
        let lastPrice = parseFloat(t.lastPrice);

        // Sunday detection (último domingo en los klines)
        let minSunday=Infinity, maxSunday=-Infinity;
        let latestSunday=0;
        klines.forEach(arr=>{
          let ts = arr[0];
          let date = new Date(ts);
          if(date.getUTCDay()===0 && date.getTime()>latestSunday){
            latestSunday = date.setUTCHours(0,0,0,0);
          }
        });
        klines.forEach(arr=>{
          let ts = arr[0];
          let date = new Date(ts);
          if(date.getUTCDay()===0 && date.setUTCHours(0,0,0,0)===latestSunday){
            let low = parseFloat(arr[3]), high = parseFloat(arr[2]);
            if(low < minSunday) minSunday = low;
            if(high > maxSunday) maxSunday = high;
          }
        });
        if(minSunday===Infinity) {
          minSunday = Math.min(...klines.map(a=>parseFloat(a[3])));
          console.warn("No se encontró minSunday para", symbol, "usa:", minSunday);
        }
        if(maxSunday===-Infinity) {
          maxSunday = Math.max(...klines.map(a=>parseFloat(a[2])));
          console.warn("No se encontró maxSunday para", symbol, "usa:", maxSunday);
        }

        // Score principal
        let score = 1;
        if(lastPrice > minSunday) score+=3;
        if(lastPrice > ema28) score+=2;
        if(rsi14 > 55) score+=2;
        if(lastPrice < ema28) score-=2;
        if(rsi14 < 45) score-=2;
        if(lastPrice > maxSunday) score+=2;
        if(lastPrice < minSunday) score-=2;
        score = Math.max(1, Math.min(10, score));
        let phase = getPhase(score);

        // Score previo (de localStorage)
        let prevScore = prevScores[symbol] || score;
        newPrevScores[symbol] = score;

        // Alerta si cambia la fase
        if (prevScore !== score) {
          newAlerts.push({ time: Date.now(), symbol, prevScore, score, phase });
          if (newAlerts.length > 20) newAlerts = newAlerts.slice(-20);
        }

        // Log para depuración
        console.log(`SYM:${symbol} P:${lastPrice} EMA:${ema28.toFixed(4)} RSI:${rsi14.toFixed(2)} MinDom:${minSunday} MaxDom:${maxSunday} SCORE:${score} PHASE:${phase}`);

        // Guardar resultado
        results.push({ symbol, lastPrice, ema28, rsi14, minSunday, maxSunday, score, prevScore, phase });

      } catch(err) {
        console.error("Error procesando símbolo:", symbol, err);
      }
    }

    // Guardar score previo y alertas en localStorage
    localStorage.setItem('prevScores', JSON.stringify(newPrevScores));
    localStorage.setItem('prevAlerts', JSON.stringify(newAlerts));

    // Renderiza la tabla (tú adaptas esto según tus columnas y lógica)
    document.getElementById('panel').innerHTML = makeTable(results);

  } catch(e) {
    document.getElementById('panel').innerHTML = '';
    document.getElementById('error').textContent = 'Error cargando datos: '+(e.message||e);
    console.error("ERROR GLOBAL:", e);
  }
}
main();
