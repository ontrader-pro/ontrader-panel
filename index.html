<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>OnTrader Index Panel</title>
  <style>
    body { background: #101729; color: #fff; font-family: Arial, sans-serif; }
    h1, h2 { color: #25f0ff; text-align: center; }
    table { width: 100%; border-collapse: collapse; margin: 18px 0; }
    th, td { border: 1px solid #222; padding: 5px 7px; text-align: center; font-size: 15px; }
    thead { background: #1f2a44; color: #25f0ff; }
    .bull { background: rgba(0,255,0,0.08); }
    .bear { background: rgba(255,0,0,0.08); }
    .mid { background: rgba(255,165,0,0.06); }
    .high { color: limegreen; }
    .low { color: red; }
    #panel { max-width: 1400px; margin: auto; }
    #error { color: #f55; text-align: center; margin: 10px 0; }
    .small { font-size: 12px; color: #aaa; }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel</h1>
  <div id="panel"><div>Cargando datosâ€¦</div></div>
  <div id="error"></div>

  <script>
    // ParÃ¡metros principales
    const TOP_LIMIT = 50; // top 50 por capitalizaciÃ³n/volumen
    const INTERVAL = "15m";
    const EMA_PERIOD = 28;
    const RSI_PERIOD = 14;
    const STABLES = ['USDT', 'USDC', 'BUSD', 'TUSD', 'DAI', 'USDP', 'GUSD', 'USDN'];

    // Carga previos de localStorage
    let prevScores = JSON.parse(localStorage.getItem('prevScores') || '{}');
    let prevAlerts = JSON.parse(localStorage.getItem('prevAlerts') || '[]');

    // EMA y RSI
    function ema(arr, period) {
      let k = 2 / (period + 1);
      return arr.reduce((a, v, i) => i ? v * k + a * (1 - k) : v, 0);
    }
    function rsi(arr, period) {
      let gains = 0, losses = 0;
      for (let i = 1; i < arr.length; i++) {
        let diff = arr[i] - arr[i-1];
        if (diff > 0) gains += diff; else losses -= diff;
      }
      let avgGain = gains / period, avgLoss = losses / period || 1e-6, rs = avgGain / avgLoss;
      return 100 - 100 / (1 + rs);
    }
    function getPhase(score) {
      if (score <= 3) return 'ðŸ”´ Oversold';
      if (score < 4.9) return 'ðŸ”´ Bearish Incline';
      if (score < 6) return 'ðŸŸ  Accumulation';
      if (score < 8.1) return 'ðŸŸ¡ Bullish Incline';
      return 'ðŸŸ¢ Overbought';
    }

    async function main() {
      try {
        document.getElementById('panel').innerHTML = 'Cargando...';
        document.getElementById('error').textContent = '';
        let res = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr');
        let tickers = await res.json();
        // Filtrar stablecoins y pares que no terminen en USDT (solo futuros)
        tickers = tickers.filter(t => !STABLES.some(stable => t.symbol.endsWith(stable)) && t.symbol.endsWith('USDT'));
        tickers = tickers.sort((a,b)=>parseFloat(b.quoteVolume)-parseFloat(a.quoteVolume)).slice(0, TOP_LIMIT);
        let results = [];
        let newPrevScores = {};
        let newAlerts = prevAlerts.slice();

        for (let t of tickers) {
          let symbol = t.symbol;
          try {
            let url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${INTERVAL}&limit=100`;
            let klineRes = await fetch(url);
            let klines = await klineRes.json();
            if (!Array.isArray(klines) || klines.length < 30) continue;
            let closes = klines.map(x=>parseFloat(x[4]));
            let ema28 = ema(closes.slice(-EMA_PERIOD-1), EMA_PERIOD);
            let rsi14 = rsi(closes.slice(-RSI_PERIOD-1), RSI_PERIOD);
            let lastPrice = parseFloat(t.lastPrice);
            // Buscar Ãºltimo domingo en los klines
            let minSunday=Infinity, maxSunday=-Infinity, latestSunday=0;
            klines.forEach(arr=>{
              let ts = arr[0];
              let date = new Date(ts);
              if(date.getUTCDay()===0 && date.getTime()>latestSunday){
                latestSunday = date.setUTCHours(0,0,0,0);
              }
            });
            klines.forEach(arr=>{
              let ts = arr[0];
              let date = new Date(ts);
              if(date.getUTCDay()===0 && date.setUTCHours(0,0,0,0)===latestSunday){
                let low = parseFloat(arr[3]), high = parseFloat(arr[2]);
                if(low < minSunday) minSunday = low;
                if(high > maxSunday) maxSunday = high;
              }
            });
            // Si no hay domingo, usar extremos
            if(minSunday===Infinity) minSunday = Math.min(...klines.map(a=>parseFloat(a[3])));
            if(maxSunday===-Infinity) maxSunday = Math.max(...klines.map(a=>parseFloat(a[2])));

            // Score principal (con regla extra solicitada)
            let score = 1;
            if(lastPrice > minSunday) score+=3;
            if(lastPrice > ema28) score+=2;
            if(rsi14 > 55) score+=2;
            if(lastPrice < ema28) score-=2;
            if(rsi14 < 45) score-=2;
            if(lastPrice > maxSunday) score+=2;
            if(lastPrice < minSunday) score-=2;

            // Reglas de lÃ­mite
            if(lastPrice < minSunday) {
              score = Math.min(score, 5);
            } else {
              score = Math.min(score, 10);
            }
            score = Math.max(1, score);

            let phase = getPhase(score);
            let prevScore = prevScores[symbol] || score;
            newPrevScores[symbol] = score;

            // Guardar alertas sÃ³lo si cambia la fase/score
            if (prevScore !== score) {
              newAlerts.push({ time: Date.now(), symbol, prevScore, score, phase });
              if (newAlerts.length > 20) newAlerts = newAlerts.slice(-20);
            }

            results.push({ symbol, lastPrice, score, prevScore, phase });
          } catch(err) { /* continÃºa con el siguiente */ }
        }

        // Guardar en localStorage
        localStorage.setItem('prevScores', JSON.stringify(newPrevScores));
        localStorage.setItem('prevAlerts', JSON.stringify(newAlerts));

        // Armado de tablas
        // --- Top 10 bullish (mayor score)
        let bullish = results.slice().sort((a,b)=>b.score-a.score).slice(0,10);
        // --- Top 10 bearish (menor score)
        let bearish = results.slice().sort((a,b)=>a.score-b.score).slice(0,10);
        // --- Ãšltimas 10 alertas
        let lastAlerts = newAlerts.slice(-10).reverse();

        // --- Top 10 subidas y bajadas de score
        let upMoves = results.filter(r=>r.score > r.prevScore)
          .sort((a,b)=>(b.score-b.prevScore)-(a.score-a.prevScore)).slice(0,10);
        let downMoves = results.filter(r=>r.score < r.prevScore)
          .sort((a,b)=>(a.score-a.prevScore)-(b.score-b.prevScore)).slice(0,10);

        // Render
        let html = `
          <h2>Top 10 Bullish</h2>
          ${makeTable(bullish, "bull")}
          <h2>Top 10 Bearish</h2>
          ${makeTable(bearish, "bear")}
          <h2>Ãšltimas 10 Alertas</h2>
          ${makeAlertTable(lastAlerts)}
          <h2>Top 10 Cambios Score Al Alza</h2>
          ${makeChangeTable(upMoves, true)}
          <h2>Top 10 Cambios Score A La Baja</h2>
          ${makeChangeTable(downMoves, false)}
        `;
        document.getElementById('panel').innerHTML = html;

      } catch(e) {
        document.getElementById('panel').innerHTML = '';
        document.getElementById('error').textContent = 'Error cargando datos: '+(e.message||e);
      }
    }

    function makeTable(arr, type) {
      return `<table>
        <thead><tr><th>SÃ­mbolo</th><th>Ãšlt. Precio</th><th>Score</th><th>Score previo</th><th>Fase</th></tr></thead>
        <tbody>
          ${arr.map(r=>{
            return `<tr class="${type}">
              <td>${r.symbol}</td>
              <td>${Number(r.lastPrice).toFixed(6)}</td>
              <td>${r.score}</td>
              <td>${r.prevScore}</td>
              <td>${r.phase}</td>
            </tr>`
          }).join('')}
        </tbody>
      </table>`;
    }

    function makeAlertTable(arr) {
      if (!arr.length) return '<div class="small">Sin alertas recientes.</div>';
      return `<table>
        <thead><tr><th>Hora</th><th>SÃ­mbolo</th><th>Score previo</th><th>Nuevo score</th><th>Fase</th></tr></thead>
        <tbody>
          ${arr.map(a=>`
            <tr>
              <td>${new Date(a.time).toLocaleTimeString()}</td>
              <td>${a.symbol}</td>
              <td>${a.prevScore}</td>
              <td>${a.score}</td>
              <td>${a.phase}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>`;
    }

    function makeChangeTable(arr, up) {
      if (!arr.length) return '<div class="small">Sin movimientos recientes.</div>';
      return `<table>
        <thead><tr><th>SÃ­mbolo</th><th>Score previo</th><th>Score actual</th><th>Diferencia</th><th>Fase</th></tr></thead>
        <tbody>
          ${arr.map(r=>`
            <tr>
              <td>${r.symbol}</td>
              <td>${r.prevScore}</td>
              <td>${r.score}</td>
              <td>${up ? "+" : ""}${(r.score - r.prevScore).toFixed(2)}</td>
              <td>${r.phase}</td>
            </tr>
          `).join('')}
        </tbody>
      </table>`;
    }

    main();
    setInterval(main, 180000); // refresca cada 3 minutos
  </script>
</body>
</html>
