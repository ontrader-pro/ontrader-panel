<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OnTrader Binance Futures Panel</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #101729; color: #fff; font-family: sans-serif; }
    h1 { text-align: center; color: #25f0ff; font-size: 1.5rem; }
    .loading { text-align: center; padding: 50px; color: #888; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #333; padding: 4px; text-align: center; font-size: 0.92rem;}
    thead { background: #1f2a44; color: #25f0ff; }
    .score-prev { color: #ccc; font-size: 0.9em; }
    #error-box { text-align: center; color: #f55; padding: 6px; }
  </style>
</head>
<body>
  <h1>OnTrader Binance Futures Panel</h1>
  <div id="panel"><div class="loading">Cargando datos‚Ä¶</div></div>
  <div id="error-box"></div>
  <script>
    const API = "https://fapi.binance.com";
    const PROXY = url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
    const STABLES = ['BUSD','TUSD','USDC','DAI','USDT'];
    const REFRESH_INTERVAL = 120000; // 2 minutos
    const PANEL = document.getElementById('panel');
    const ERROR = document.getElementById('error-box');
    let cache = [];

    // Helpers
    function calcEMA(arr, p) {
      const k = 2 / (p + 1);
      return arr.reduce((a, v, i) => i ? v * k + a * (1 - k) : v, 0);
    }
    function calcRSI(arr) {
      let gains = 0, losses = 0;
      for (let i = 1; i < arr.length; i++) {
        const diff = arr[i] - arr[i - 1];
        diff > 0 ? gains += diff : losses -= diff;
      }
      const avgGain = gains / (arr.length - 1), avgLoss = losses / (arr.length - 1) || 1e-6;
      const rs = avgGain / avgLoss;
      return 100 - (100 / (1 + rs));
    }
    function phaseText(s) {
      if (s <= 3.0) return 'üî¥ Oversold';
      else if (s < 4.9) return 'üî¥ Bearish Incline';
      else if (s < 6.0) return 'üü† Accumulation';
      else if (s < 8.1) return 'üü° Bullish Incline';
      else return 'üü¢ Overbought';
    }

    function computeScore({ price, minD, maxD, ema28, rsi15m, rsi5m, ema5m, rsi4m }) {
      let score = 1;
      // Jerarqu√≠a de puntaje
      if (price > minD) score += 3;
      if (price > maxD) score += 2;
      if (rsi15m > 50 && price > ema28) score += 2;
      if (rsi15m < 50 && price < ema28) score -= 2;
      if (rsi5m > 70 && price > ema5m) score += 1;
      if (rsi5m < 30 && price < ema5m) score -= 1;
      if (rsi4m < 15) score += 0.5;
      if (rsi4m > 85) score -= 0.5;
      return Math.min(10, Math.max(1, score));
    }

    async function getKlines(symbol, interval, limit=28) {
      // Usamos proxy para evitar CORS
      const url = PROXY(`${API}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`);
      try {
        const raw = await fetch(url).then(r => r.json());
        return raw.map(c => +c[4]); // Solo precios de cierre
      } catch (e) { return []; }
    }

    function savePrevScore(symbol, score) {
      let prev = JSON.parse(localStorage.getItem('prevScores') || '{}');
      prev[symbol] = score;
      localStorage.setItem('prevScores', JSON.stringify(prev));
    }
    function getPrevScore(symbol) {
      let prev = JSON.parse(localStorage.getItem('prevScores') || '{}');
      return prev[symbol] || "";
    }

    async function loadData() {
      PANEL.innerHTML = '<div class="loading">Cargando datos‚Ä¶</div>';
      ERROR.innerText = '';
      try {
        // 1. Traer el 24hr ticker (todos los futuros)
        const data = await fetch(PROXY(`${API}/fapi/v1/ticker/24hr`)).then(r => r.json());
        // 2. Filtrar top 100 (por volumen) y excluir stables
        const list = data.filter(d =>
          d.symbol.endsWith("USDT") &&
          !STABLES.some(st => d.symbol === st + "USDT")
        ).sort((a, b) => b.quoteVolume - a.quoteVolume).slice(0, 100);

        // 3. Obtener datos hist√≥ricos (min/max domingo, EMA28, RSI para cada uno)
        // Para demo, minD y maxD = low/high 24h. En producci√≥n, reemplaza por datos reales de domingo.
        // Klines: 28 para EMA, 15 para RSI15m, 5 para RSI5m, 4 para RSI4m
        let promises = list.map(async d => {
          let [closes28m, closes15m, closes5m, closes4m] = await Promise.all([
            getKlines(d.symbol, "15m", 28),
            getKlines(d.symbol, "15m", 15),
            getKlines(d.symbol, "5m", 5),
            getKlines(d.symbol, "4m", 4)
          ]);
          const ema28 = closes28m.length === 28 ? calcEMA(closes28m, 28) : +d.lastPrice;
          const rsi15m = closes15m.length === 15 ? calcRSI(closes15m) : 50;
          const ema5m = closes5m.length === 5 ? calcEMA(closes5m, 5) : +d.lastPrice;
          const rsi5m = closes5m.length === 5 ? calcRSI(closes5m) : 50;
          const rsi4m = closes4m.length === 4 ? calcRSI(closes4m) : 50;
          // Demo: usamos low/high 24h como min/max domingo
          const minD = +d.lowPrice, maxD = +d.highPrice;
          const price = +d.lastPrice;
          let prevScore = getPrevScore(d.symbol);
          let score = computeScore({ price, minD, maxD, ema28, rsi15m, rsi5m, ema5m, rsi4m });
          savePrevScore(d.symbol, score);
          return { ...d, price, minD, maxD, ema28, rsi15m, rsi5m, ema5m, rsi4m, score, prevScore };
        });

        const final = await Promise.all(promises);
        cache = final;
        localStorage.setItem('ontraderCacheBinance', JSON.stringify(final));
        renderAll();
      } catch (e) {
        console.error(e);
        const saved = localStorage.getItem('ontraderCacheBinance');
        if (saved) {
          cache = JSON.parse(saved);
          ERROR.innerText = 'Mostrando datos de cach√©';
          renderAll();
        } else {
          PANEL.innerHTML = '';
          ERROR.innerText = 'Error cargando datos: ' + e.message;
        }
      }
    }

    function renderAll() {
      const cols = [
        "symbol","price","minD","maxD","ema28","rsi15m","rsi5m","ema5m","rsi4m","score","prevScore",
        "lastPrice","priceChangePercent","volume","quoteVolume","highPrice","lowPrice","openPrice","weightedAvgPrice"
      ];
      let html = `<table><thead><tr>`;
      cols.forEach(c => html += `<th>${c}</th>`);
      html += `<th>Phase</th></tr></thead><tbody>`;
      cache.forEach(d => {
        html += `<tr>`;
        cols.forEach(c => {
          if (c === "score" && d.prevScore !== "" && +d.prevScore !== d.score) {
            html += `<td><span class="score-prev">${d.prevScore}</span> ‚Üí <b>${d.score}</b></td>`;
          } else {
            html += `<td>${d[c] !== undefined ? (typeof d[c] === "number" ? d[c].toFixed(6) : d[c]) : ""}</td>`;
          }
        });
        html += `<td>${phaseText(d.score)}</td></tr>`;
      });
      html += `</tbody></table>`;
      PANEL.innerHTML = html;
    }

    // Auto refresh cada 2 minutos, JAM√ÅS MANUAL
    loadData();
    setInterval(loadData, REFRESH_INTERVAL);
  </script>
</body>
</html>
