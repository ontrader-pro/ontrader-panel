<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OnTrader Index Panel</title>
  <style>
    :root {
      --main-color: #25f0ff;
      --bg-color: #101729;
      --bg-hover: #080d18;
    }
    body {
      background: var(--bg-color);
      color: #fff;
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: var(--main-color);
      margin-bottom: 10px;
    }
    #panel {
      overflow-x: auto;
      text-align: center;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #333;
      padding: 6px;
      text-align: center;
      min-width: 80px;
    }
    thead {
      background: #1f2a44;
      color: var(--main-color);
    }
    .high { color: limegreen; font-weight: bold; }
    .mid  { color: orange;    font-weight: bold; }
    .low  { color: red;       font-weight: bold; }
    .highlight-bull { background: rgba(0,255,0,0.2); }
    .highlight-bear { background: rgba(255,0,0,0.2); }
    #error-box {
      margin-top: 20px;
      color: #f55;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel</h1>
  <div id="panel">Inicializando‚Ä¶</div>
  <div id="error-box" role="alert"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const CG_BASE     = 'https://api.coingecko.com/api/v3';
      const BINANCE_API = url => 'https://thingproxy.freeboard.io/fetch/' + url;
      const STABLES     = ['usdt','usdc','busd','dai','tusd','usdp','gusd','usdn'];
      const PER_PAGE    = 250;
      const PAGES       = 4;      // Top 1000
      const REFRESH_HEAVY = 2*60*1000;  // 2min
      const REFRESH_LIGHT =   60*1000;  // 1min
      const ONE_HOUR      = 60*60*1000;

      let heavyCache = [];
      let heavyTS    = 0;
      let dataGlobal = [];
      let durations  = {};
      const panel    = document.getElementById('panel');
      const errBox   = document.getElementById('error-box');

      // F√≥rmula matem√°tica:
      // x1 = 1 si precio < minDomingo, 0 en otro caso
      // x2 = 1 si precio < EMA28,        0 en otro caso
      // x3 = 1 si RSI14   < 50,          0 en otro caso
      // x4 = 1 si RSI14   < 30,          0 en otro caso
      // score = 1 + 2*x1 + 2*x2 + 3*x3 + 2*x4  => rango [1,10]

      function calcEMA(arr, period) {
        const k = 2/(period+1);
        return arr.reduce((prev, curr, i) => i ? curr*k + prev*(1-k) : curr, 0);
      }
      function calcRSI(arr) {
        let gains = 0, losses = 0;
        for (let i=1; i<arr.length; i++) {
          const diff = arr[i] - arr[i-1];
          if (diff > 0) gains += diff;
          else losses -= diff;
        }
        const avgG = gains/(arr.length-1);
        const avgL = losses/(arr.length-1) || 1e-6;
        const rs   = avgG/avgL;
        return 100 - (100/(1+rs));
      }

      async function heavyLoad() {
        try {
          const now = Date.now();
          if (heavyCache.length && now - heavyTS < REFRESH_HEAVY) return heavyCache;
          heavyTS = now;
          const all = [];
          for (let page=1; page<=PAGES; page++) {
            const url = `${CG_BASE}/coins/markets` +
                        `?vs_currency=usd&order=market_cap_desc&per_page=${PER_PAGE}` +
                        `&page=${page}&sparkline=true`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`CoinGecko ${res.status}`);
            const list = await res.json();
            for (const c of list) {
              if (STABLES.includes(c.symbol)) continue;
              const spark = Array.isArray(c.sparkline_in_7d?.price) ? c.sparkline_in_7d.price : [];
              const ema28 = spark.length>=28 ? calcEMA(spark.slice(-28), 28) : c.current_price;
              const rsi14 = spark.length>=15 ? calcRSI(spark.slice(-15)) : 50;
              let minD=NaN, maxD=NaN;
              try {
                const bUrl = `https://api.binance.com/api/v3/klines?symbol=${c.symbol.toUpperCase()}USDT&interval=1d&limit=8`;
                const bRes = await fetch(BINANCE_API(bUrl));
                if (bRes.ok) {
                  const kl = await bRes.json();
                  const sun = kl.reverse().find(k=>new Date(k[0]).getUTCDay()===0) || [];
                  maxD = parseFloat(sun[2]) || NaN;
                  minD = parseFloat(sun[3]) || NaN;
                }
              } catch(_){}
              all.push({ id:c.id, symbol:c.symbol.toUpperCase(), ema28, rsi14, minD, maxD });
            }
          }
          heavyCache = all;
          return all;
        } catch(e) {
          throw new Error('heavyLoad: ' + e.message);
        }
      }

      async function lightLoad(heavy) {
        try {
          const ids = heavy.map(h=>h.id).join(',');
          const res = await fetch(`${CG_BASE}/simple/price?ids=${ids}&vs_currencies=usd`);
          if (!res.ok) throw new Error(`Prices ${res.status}`);
          const prices = await res.json();
          dataGlobal = heavy.map(h=>{
            const p  = prices[h.id]?.usd||0;
            const x1 = p < h.minD  ? 1:0;
            const x2 = p < h.ema28 ? 1:0;
            const x3 = h.rsi14 < 50 ? 1:0;
            const x4 = h.rsi14 < 30 ? 1:0;
            let score = 1 + 2*x1 + 2*x2 + 3*x3 + 2*x4;
            score = Math.max(1, Math.min(10, score));
            let phase = 'üî¥ Oversold';
            if (score >= 8.1) phase = 'üü¢ Overbought';
            else if(score >= 6.0) phase = 'üü° Bullish Incline';
            else if(score >= 4.9) phase = 'üü† Accumulation';
            else if(score >= 3.1) phase = 'üî¥ Bearish Incline';
            return { symbol:h.symbol, price:p, index:score.toFixed(2), phase };
          });
          renderTables();
        } catch(e) {
          throw new Error('lightLoad: ' + e.message);
        }
      }

      function renderTables() {
        panel.innerHTML = '';
        const top = [...dataGlobal].sort((a,b)=>b.index-a.index).slice(0,10);
        const bot = [...dataGlobal].sort((a,b)=>a.index-b.index).slice(0,10);
        panel.innerHTML = `
          <h2>Top 10 Bullish</h2>${makeTable(top)}
          <h2>Top 10 Bearish</h2>${makeTable(bot)}`;
      }

      function makeTable(arr) {
        let html = '<table><thead><tr>' +
                   '<th>Symbol</th><th>Price</th><th>Score</th><th>Phase</th>' +
                   '</tr></thead><tbody>';
        const now = Date.now();
        for (const d of arr) {
          const idx = parseFloat(d.index);
          durations[d.symbol] = durations[d.symbol] || {};
          if (idx>=6) durations[d.symbol].bullStart = durations[d.symbol].bullStart || now;
          else delete durations[d.symbol].bullStart;
          if (idx<=3) durations[d.symbol].bearStart = durations[d.symbol].bearStart || now;
          else delete durations[d.symbol].bearStart;
          const highlight = durations[d.symbol].bullStart&& now-durations[d.symbol].bullStart>ONE_HOUR ? 'highlight-bull'
                              : durations[d.symbol].bearStart&&now-durations[d.symbol].bearStart>ONE_HOUR ? 'highlight-bear' : '';
          const cls = idx>=8 ? 'high' : idx>=5 ? 'mid' : 'low';
          html += `<tr class="${highlight}">` +
                  `<td>${d.symbol}</td>` +
                  `<td>${d.price}</td>` +
                  `<td class="${cls}">${d.index}</td>` +
                  `<td>${d.phase}</td>` +
                  `</tr>`;
        }
        return html + '</tbody></table>';
      }

      // Orquestaci√≥n
      (async ()=>{
        try {
          const heavy = await heavyLoad();
          const light = await lightLoad(heavy);
          panel.innerHTML = '';
          setInterval(async ()=>{
            try { await lightLoad(heavy); }
            catch(e){ throw e; }
          }, REFRESH_LIGHT);
          setInterval(async ()=>{
            try { heavy = await heavyLoad(); }
            catch(e){ throw e; }
          }, REFRESH_HEAVY);
        } catch(e) {
          panel.innerHTML = '';
          errBox.innerText = e.message;
        }
      })();
    });
  </script>
</body>
</html>
