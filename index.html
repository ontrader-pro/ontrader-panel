<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>OnTrader Index Panel</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; background: #101729; color: #fff; font-family: sans-serif; }
    h1 { margin: 0; padding: 10px; text-align: center; color: #25f0ff; font-size: 1.5rem; }
    #panel { overflow: auto; padding: 0 10px; }
    .loading { text-align: center; padding: 50px; font-size: 1.2rem; color: #888; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 0.9rem; }
    th, td { border: 1px solid #333; padding: 6px; text-align: center; }
    thead { background: #1f2a44; color: #25f0ff; }
    .high { color: limegreen; }
    .mid { color: orange; }
    .low { color: red; }
    #error-box { text-align: center; color: #f55; padding: 5px; }
    #alert-box { position: fixed; bottom: 10px; right: 10px; background: #ff4444; color: #fff; padding: 8px 12px; border-radius: 4px; display: none; z-index: 1000; }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel (Futures Top 100)</h1>
  <div id="panel"><div class="loading">Cargando datos‚Ä¶</div></div>
  <div id="error-box"></div>
  <div id="alert-box"></div>
  <script>
    const API = "https://fapi.binance.com";
    const STABLES = ['USDT','USDC','BUSD','TUSD','USDP','DAI','FDUSD','EUR','TRY','BRL','ARS','PYUSD'];
    const panel = document.getElementById('panel');
    const errorBox = document.getElementById('error-box');
    const alertBox = document.getElementById('alert-box');
    const sound = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
    let prevScores = JSON.parse(localStorage.getItem('ontraderScores')||'{}');
    let alerts = [];
    const REFRESH_MS = 120000;

    // Bypass multi-proxy
    async function fetchWithProxy(url) {
      let errorMsg = '';
      const proxies = [
        u => u, // Direct, try first
        u => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
        u => `https://thingproxy.freeboard.io/fetch/${u}`
      ];
      for (const wrap of proxies) {
        try {
          const resp = await fetch(wrap(url));
          const data = await resp.json();
          if (Array.isArray(data) || (typeof data === 'object' && data !== null)) return data;
        } catch(e) {
          errorMsg = e.message;
        }
      }
      throw new Error("No se pudo obtener datos de Binance. " + errorMsg);
    }

    function phaseText(s) {
      if (s <= 3.0) return 'üî¥ Oversold';
      else if (s < 4.9) return 'üî¥ Bearish Incline';
      else if (s < 6.0) return 'üü† Accumulation';
      else if (s < 8.1) return 'üü° Bullish Incline';
      else return 'üü¢ Overbought';
    }

    // Score formula (puedes personalizar aqu√≠ seg√∫n tu nueva l√≥gica jer√°rquica)
    function calcScore(d) {
      let score = 1;
      // 1) Precio > m√≠nimo del domingo: +3
      if (d.lastPrice > d.sunMin) score += 3;
      // 2) Precio > m√°ximo del domingo: +2 extra
      if (d.lastPrice > d.sunMax) score += 2;
      // 3) En 15m RSI>50 y precio>EMA28: +2 | RSI<50 y precio<EMA28: -2
      if (d.rsi15m > 50 && d.lastPrice > d.ema15m) score += 2;
      if (d.rsi15m < 50 && d.lastPrice < d.ema15m) score -= 2;
      // 4) En 5m RSI>70 y precio>EMA28: +1 | RSI<30 y precio<EMA28: -1
      if (d.rsi5m > 70 && d.lastPrice > d.ema5m) score += 1;
      if (d.rsi5m < 30 && d.lastPrice < d.ema5m) score -= 1;
      // 5) En 4m RSI<15: +0.5 | RSI>85: -0.5
      if (d.rsi4m < 15) score += 0.5;
      if (d.rsi4m > 85) score -= 0.5;
      return Math.max(1, Math.min(10, score));
    }

    function showAlert(msg) {
      alertBox.innerText = msg;
      alertBox.style.display = 'block';
      try { sound.currentTime = 0; sound.play(); } catch{}
      setTimeout(() => { alertBox.style.display = 'none'; sound.pause(); }, 7000);
    }

    async function getSunExtremes(symbol) {
      // Aqu√≠ podr√≠as integrar un endpoint que te devuelva el m√≠nimo y m√°ximo dominical real
      // Placeholder: usar el m√≠nimo/m√°ximo de 7d si no tienes otro endpoint.
      return { sunMin: Number.POSITIVE_INFINITY, sunMax: Number.NEGATIVE_INFINITY };
    }

    // Simulaci√≥n de RSI y EMA (modificar por tus c√°lculos reales si tienes endpoint)
    function dummyRSI() { return Math.floor(Math.random()*100); }
    function dummyEMA(price) { return price * (0.99 + Math.random()*0.02); }

    async function loadData() {
      panel.innerHTML = '<div class="loading">Cargando datos‚Ä¶</div>';
      errorBox.innerText = '';
      try {
        const data = await fetchWithProxy(`${API}/fapi/v1/ticker/24hr`);
        if (!Array.isArray(data)) throw new Error("Respuesta inesperada de la API: " + JSON.stringify(data));

        // Top 100 por volumen, excluyendo stables
        let list = data
          .filter(d => d.symbol.endsWith("USDT") && !STABLES.some(st => d.symbol === st + "USDT"))
          .sort((a, b) => b.quoteVolume - a.quoteVolume)
          .slice(0, 100);

        // A√±adir datos ficticios de RSI/EMA para demo, deber√≠as reemplazar por datos reales
        for (let d of list) {
          d.lastPrice = parseFloat(d.lastPrice);
          d.rsi15m = dummyRSI(); // <--- REEMPLAZA por consulta real si tienes endpoint o websocket
          d.ema15m = dummyEMA(d.lastPrice);
          d.rsi5m = dummyRSI();
          d.ema5m = dummyEMA(d.lastPrice);
          d.rsi4m = dummyRSI();
          // Dominicales placeholder
          d.sunMin = d.lowPrice ? parseFloat(d.lowPrice) : d.lastPrice * 0.95;
          d.sunMax = d.highPrice ? parseFloat(d.highPrice) : d.lastPrice * 1.05;
        }

        // Calcular score actual y traer previo
        const updatedPrevScores = {};
        list.forEach(d => {
          const prev = prevScores[d.symbol] || null;
          d.scorePrev = prev ? prev.score : '';
          d.score = calcScore(d);
          updatedPrevScores[d.symbol] = { score: d.score };
        });
        prevScores = updatedPrevScores;
        localStorage.setItem('ontraderScores', JSON.stringify(updatedPrevScores));

        // Alertas si cambia de fase
        alerts = [];
        list.forEach(d => {
          if (d.scorePrev !== '' && phaseText(d.scorePrev) !== phaseText(d.score)) {
            alerts.push({ time: new Date().toLocaleTimeString(), symbol: d.symbol, prev: phaseText(d.scorePrev), now: phaseText(d.score) });
            showAlert(`üö® ${d.symbol}: ${phaseText(d.scorePrev)} ‚Üí ${phaseText(d.score)}`);
          }
        });
        // Render
        renderTable(list);
      } catch(e) {
        errorBox.innerText = 'Error cargando datos: ' + e.message;
        panel.innerHTML = '';
      }
    }

    function renderTable(list) {
      let html = `<table><thead>
        <tr>
          <th>Symbol</th><th>Last Price</th><th>Volume</th>
          <th>Score Prev</th><th>Score</th><th>Phase</th>
          <th>RSI 15m</th><th>EMA 15m</th>
          <th>RSI 5m</th><th>EMA 5m</th>
          <th>RSI 4m</th>
          <th>Min Sunday</th><th>Max Sunday</th>
        </tr></thead><tbody>`;
      for (const d of list) {
        html += `<tr>
          <td>${d.symbol}</td>
          <td>${d.lastPrice.toFixed(6)}</td>
          <td>${(+d.quoteVolume).toFixed(0)}</td>
          <td>${d.scorePrev}</td>
          <td class="${d.score >= 8 ? 'high' : d.score >= 5 ? 'mid' : 'low'}">${d.score}</td>
          <td>${phaseText(d.score)}</td>
          <td>${d.rsi15m}</td><td>${d.ema15m.toFixed(4)}</td>
          <td>${d.rsi5m}</td><td>${d.ema5m.toFixed(4)}</td>
          <td>${d.rsi4m}</td>
          <td>${d.sunMin.toFixed(6)}</td><td>${d.sunMax.toFixed(6)}</td>
        </tr>`;
      }
      html += '</tbody></table>';
      // Alerts
      if (alerts.length > 0) {
        html += `<h2>Alerts</h2><table><thead>
          <tr><th>Time</th><th>Symbol</th><th>Prev Phase</th><th>New Phase</th></tr></thead><tbody>`;
        for (const a of alerts)
          html += `<tr><td>${a.time}</td><td>${a.symbol}</td><td>${a.prev}</td><td>${a.now}</td></tr>`;
        html += '</tbody></table>';
      }
      panel.innerHTML = html;
    }

    loadData();
    setInterval(loadData, REFRESH_MS);
  </script>
</body>
</html>
