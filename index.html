<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>OnTrader Index Panel (Futures)</title>
  <style>
    body { background: #101729; color: #fff; font-family: sans-serif; margin: 0; padding: 0; }
    h1 { text-align: center; color: #25f0ff; }
    #panel { padding: 10px; }
    .loading { text-align: center; padding: 40px; font-size: 1.2rem; }
    table { width: 100%; border-collapse: collapse; margin: 10px 0; }
    th, td { border: 1px solid #333; padding: 6px; text-align: center; }
    thead { background: #1f2a44; color: #25f0ff; }
    .high { color: limegreen; }
    .mid { color: orange; }
    .low { color: red; }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel (Futures)</h1>
  <div id="panel"><div class="loading">Cargando datos de Binance Futures‚Ä¶</div></div>
  <script>
    const STABLES = ['USDT', 'USDC', 'BUSD', 'DAI', 'TUSD', 'USDP', 'GUSD', 'USDN'];
    const panel = document.getElementById('panel');
    const REFRESH = 120000;
    let previousScores = JSON.parse(localStorage.getItem('ontraderScores') || '{}');

    function isStable(symbol) {
      return STABLES.some(st => symbol.endsWith(st));
    }

    function calcEMA(arr, period) {
      const k = 2 / (period + 1);
      return arr.reduce((a, v, i) => (i ? v * k + a * (1 - k) : v), 0);
    }

    function calcRSI(prices, period = 14) {
      let gain = 0, loss = 0;
      for (let i = 1; i < prices.length; i++) {
        const diff = prices[i] - prices[i - 1];
        if (diff > 0) gain += diff;
        else loss -= diff;
      }
      const avgGain = gain / period;
      const avgLoss = (loss || 1e-6) / period;
      const rs = avgGain / avgLoss;
      return 100 - 100 / (1 + rs);
    }

    // Score formula seg√∫n reglas jer√°rquicas, modificar seg√∫n tu l√≥gica nueva
    function computeScore({ price, minSunday, maxSunday, ema15m, rsi15m, ema5m, rsi5m, rsi4m }) {
      let score = 1;
      // 1) Precio > m√≠nimo domingo: +3, si > m√°ximo domingo: +2 extra
      if (price > minSunday) score += 3;
      if (price > maxSunday) score += 2;
      // 2) 15m: RSI>50 y precio>EMA28: +2 | RSI<50 y precio<EMA28: -2
      if (rsi15m > 50 && price > ema15m) score += 2;
      if (rsi15m < 50 && price < ema15m) score -= 2;
      // 3) 5m: RSI>70 y precio>EMA28: +1 | RSI<30 y precio<EMA28: -1
      if (rsi5m > 70 && price > ema5m) score += 1;
      if (rsi5m < 30 && price < ema5m) score -= 1;
      // 4) 4m: RSI<15: +0.5 | RSI>85: -0.5
      if (rsi4m < 15) score += 0.5;
      if (rsi4m > 85) score -= 0.5;
      return Math.min(10, Math.max(1, score));
    }

    function phaseText(s) {
      if (s <= 3.0) return 'üî¥ Oversold';
      else if (s < 4.9) return 'üî¥ Bearish Incline';
      else if (s < 6.0) return 'üü† Accumulation';
      else if (s < 8.1) return 'üü° Bullish Incline';
      else return 'üü¢ Overbought';
    }

    async function fetchTop100Futures() {
      // Binance Futures 24h tickers (gives volume for sorting)
      const tickers = await fetch('https://fapi.binance.com/fapi/v1/ticker/24hr').then(r => r.json());
      const sorted = tickers
        .filter(t => t.symbol.endsWith('USDT') && !isStable(t.symbol.replace('USDT','')))
        .sort((a, b) => +b.quoteVolume - +a.quoteVolume)
        .slice(0, 100);
      return sorted.map(t => t.symbol);
    }

    async function fetchKlines(symbol, interval, limit = 100) {
      const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      return fetch(url).then(r => r.json());
    }

    async function getSundayExtremes(symbol) {
      // Busca m√≠nimo y m√°ximo del domingo pasado (simple: √∫ltimos 7 d√≠as, cada 4h)
      const klines = await fetchKlines(symbol, '4h', 50); // ~8 d√≠as de 4h velas
      const sundays = [];
      for (let i = 0; i < klines.length; i++) {
        const time = new Date(klines[i][0]);
        if (time.getUTCDay() === 0) { // Domingo
          sundays.push(+klines[i][3], +klines[i][2]); // high, low
        }
      }
      if (sundays.length) {
        return { max: Math.max(...sundays), min: Math.min(...sundays) };
      }
      // fallback: √∫ltimos valores
      return { max: +klines[klines.length-1][2], min: +klines[klines.length-1][3] };
    }

    async function fetchAllData() {
      panel.innerHTML = '<div class="loading">Cargando datos de Binance Futures‚Ä¶</div>';
      const topSymbols = await fetchTop100Futures();
      const results = [];
      for (const symbol of topSymbols) {
        try {
          const [klines15m, klines5m, klines4m] = await Promise.all([
            fetchKlines(symbol, '15m', 40),
            fetchKlines(symbol, '5m', 40),
            fetchKlines(symbol, '4m', 40)
          ]);
          const price = +klines15m.at(-1)[4]; // close
          const ema15m = calcEMA(klines15m.map(k=>+k[4]), 28);
          const rsi15m = calcRSI(klines15m.map(k=>+k[4]).slice(-15));
          const ema5m = calcEMA(klines5m.map(k=>+k[4]), 28);
          const rsi5m = calcRSI(klines5m.map(k=>+k[4]).slice(-14));
          const rsi4m = calcRSI(klines4m.map(k=>+k[4]).slice(-14));
          const { min: minSunday, max: maxSunday } = await getSundayExtremes(symbol);
          const prevScore = previousScores[symbol] || null;
          const score = computeScore({ price, minSunday, maxSunday, ema15m, rsi15m, ema5m, rsi5m, rsi4m });
          results.push({
            symbol, price, minSunday, maxSunday, ema15m, rsi15m, ema5m, rsi5m, rsi4m, score, prevScore
          });
          previousScores[symbol] = score;
        } catch (e) { /* handle errors, skip this symbol */ }
      }
      localStorage.setItem('ontraderScores', JSON.stringify(previousScores));
      return results;
    }

    function renderTable(data) {
      let html = '<table><thead><tr><th>Symbol</th><th>Price</th><th>Score</th><th>Prev Score</th><th>Phase</th></tr></thead><tbody>';
      data.forEach(d => {
        const cls = d.score >= 8 ? 'high' : d.score >= 5 ? 'mid' : 'low';
        html += `<tr>
          <td>${d.symbol}</td>
          <td>${d.price.toFixed(5)}</td>
          <td class="${cls}">${d.score.toFixed(2)}</td>
          <td>${d.prevScore !== null ? d.prevScore.toFixed(2) : '-'}</td>
          <td>${phaseText(d.score)}</td>
        </tr>`;
      });
      html += '</tbody></table>';
      return html;
    }

    async function refreshPanel() {
      const data = await fetchAllData();
      panel.innerHTML = renderTable(data);
    }

    refreshPanel();
    setInterval(refreshPanel, REFRESH);
  </script>
</body>
</html>
