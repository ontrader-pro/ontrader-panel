<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OnTrader Index Panel</title>
  <style>
    :root { --main: #25f0ff; --bg: #101729; --bg-hover: #080d18; }
    body { background: var(--bg); color: #fff; font-family: sans-serif; margin: 0; padding: 20px; }
    h1 { text-align: center; color: var(--main); margin-bottom: 5px; }
    #formula { text-align: center; color: #aaa; margin-bottom: 15px; font-size: 0.9em; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #333; padding: 6px; text-align: center; }
    thead { background: #1f2a44; color: var(--main); }
    .high { color: limegreen; font-weight: bold; }
    .mid  { color: orange;    font-weight: bold; }
    .low  { color: red;       font-weight: bold; }
    .highlight-bull { background: rgba(0,255,0,0.2); }
    .highlight-bear { background: rgba(255,0,0,0.2); }
    #alert-box { position: fixed; bottom: 20px; right: 20px; background: #ff4444; color: #fff; padding: 10px 15px; border-radius: 5px; display: none; box-shadow: 0 0 6px rgba(0,0,0,0.5); z-index: 1000; }
    #error-box { color: #f55; font-weight: bold; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>OnTrader Index Panel</h1>
  <div id="formula">Score = 1 + 2·x₁ + 2·x₂ + 3·x₃ + 2·x₄</div>
  <div id="panel">Inicializando…</div>
  <div id="error-box"></div>
  <div id="alert-box"></div>

  <script>
    // 1. Extraer selectores de DOM a constantes para evitar búsquedas repetidas
    const panel = document.getElementById('panel');
    const errorBox = document.getElementById('error-box');
    const alertBox = document.getElementById('alert-box');
    const sound = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');

    window.onerror = (msg) => {
      errorBox.innerText = 'Error: ' + msg;
      return true;
    };
    if (typeof fetch !== 'function') {
      panel.innerText = 'Abra en un navegador real.';
      throw new Error('Entorno no válido');
    }

    // 2. Usar nombres más descriptivos y agrupar constantes
    const API = {
      coingecko: 'https://api.coingecko.com/api/v3',
      proxy: url => 'https://thingproxy.freeboard.io/fetch/' + url
    };
    const CONFIG = { stables: ['usdt','usdc','busd','dai','tusd','usdp','gusd','usdn'], perPage: 250, pages: 4, refreshHeavy:120e3, refreshLight:60e3, oneHour:3600e3 };

    // 3. Simplificar cálculos con funciones puras
    function calcEMA(arr,p){ const k=2/(p+1); return arr.reduce((a,v,i)=>i?v*k+a*(1-k):v,0); }
    function calcRSI(arr){ let gain=0,loss=0; for(let i=1;i<arr.length;i++){const d=arr[i]-arr[i-1]; d>0?gain+=d:loss-=d;} const ag=gain/(arr.length-1), al=loss/(arr.length-1)||1e-6; const rs=ag/al; return 100-(100/(1+rs)); }

    // 4. Unificar lógica de puntuación en función clara
    function computeScore({price,minD,ema28,rsi14}){
      const x1 = price < minD;
      const x2 = price < ema28;
      const x3 = rsi14 < 50;
      const x4 = rsi14 < 30;
      const raw = 1 + 2*x1 + 2*x2 + 3*x3 + 2*x4;
      return Math.max(1, Math.min(10, raw));
    }

    // 5. Modularizar carga de datos y renderizado (evitar función gigante)
    async function loadHeavy(){
      const now = Date.now();
      if (loadHeavy.cache && now - loadHeavy.ts < CONFIG.refreshHeavy) return loadHeavy.cache;
      loadHeavy.ts = now;
      const coins = [];
      for (let pg = 1; pg <= CONFIG.pages; pg++) {
        try {
          const res = await fetch(`${API.coingecko}/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=${CONFIG.perPage}&page=${pg}&sparkline=true`);
          const list = await res.json();
          list.forEach(c => {
            if (CONFIG.stables.includes(c.symbol)) return;
            const prices = Array.isArray(c.sparkline_in_7d?.price) ? c.sparkline_in_7d.price : [];
            const ema28 = prices.length>=28 ? calcEMA(prices.slice(-28),28) : c.current_price;
            const rsi14 = prices.length>=15 ? calcRSI(prices.slice(-15)) : 50;
            coins.push({ id:c.id, symbol:c.symbol.toUpperCase(), ema28, rsi14, priceHistory: prices });
          });
        } catch (e) { console.warn('Heavy load error', e); }
      }
      loadHeavy.cache = coins;
      return coins;
    }

    async function loadLight(coins){
      const ids = coins.map(c=>c.id).join(',');
      const res = await fetch(`${API.coingecko}/simple/price?ids=${ids}&vs_currencies=usd`);
      const prices = await res.json();
      return coins.map(c => ({ ...c, price: prices[c.id]?.usd || 0 }));
    }

    function renderTables(data){
      const top = data.slice().sort((a,b)=>b.score-a.score).slice(0,10);
      const bot = data.slice().sort((a,b)=>a.score-b.score).slice(0,10);
      panel.innerHTML = `<h2>Top 10 Bullish</h2>${makeTable(top)}<h2>Top 10 Bearish</h2>${makeTable(bot)}<h2>Last 20 Alerts</h2>${alertsTable()}`;
    }

    // Continuar refactorizando funciones auxiliares...
  </script>
</body>
</html>
